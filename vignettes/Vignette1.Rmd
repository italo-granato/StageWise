---
title: "Vignette 1: Single trait analysis with homogeneous GxE"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{StageWise Vignette1}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r include=FALSE}
knitr::opts_chunk$set(echo = TRUE,message=FALSE,warning=FALSE,comment="##",
                      fig.width=4,fig.height=4,dpi=150)
knitr::opts_knit$set(root.dir="~/Box Sync/Endelman/Software/StageWise")
```

### Preface

This vignette illustrates basic features of the package using a potato breeding dataset of nearly 950 genotypes (i.e., clones), with phenotype data from six years at one location. It is an updated version of the dataset published by [Endelman et al. (2018)](https://doi.org/10.1534/genetics.118.300685). This vignette covers single trait analysis, under the assumption that all environments have the same genetic correlation (i.e., compound symmetry). The analysis of multiple locations with different correlations are covered in [Vignette 2](https://jendelman.github.io/StageWise/Vignette2.html), and the analysis of correlated traits is covered in [Vignette 3](https://jendelman.github.io/StageWise/Vignette3.html).

There are five main functions in the package:

* `read_geno`

* `Stage1`

* `Stage2`

* `blup_prep`

* `blup`

The package depends on ASReml-R (version 4.1.0.148 or later), which requires a license from [VSN International](https://www.vsni.co.uk/software/asreml-r). 

### Stage 1

In Stage 1, the data for each environment are analyzed independently, which allows for the selection of different models tailored to different experimental designs and patterns of spatial variation. The `Stage1` function in the package offers a number of commonly used analysis methods, but it also possible to use other software for Stage 1. For a linear model with only fixed and i.i.d. random effects, the argument `solver="asreml"` triggers the use of ASReml-R for variance component estimation. Another option is `solver="spats"`, which triggers the use of R package [SpATS](https://cran.r-project.org/web/packages/SpATS/index.html) to fit a 2D spline (in addition to fixed or i.i.d. effects). Regardless of which solver is used, at least some of the individuals should be replicated (which includes augmented designs with repeated checks). If you have no replication within environment, skip Stage 1 and go to Stage 2.

There are two required columns in the CSV file of phenotype data used in `Stage1`: "id" contains the individual identifier and is matched against the information from the genotype input file; and "env" is the name of the environment, which is typically a location x year combination. (This vignette illustrates the analysis of multiple years from one location, or when multiple locations are similar enough that the genotype x location effect can be neglected. For the analysis of correlated locations, consult [Vignette 2](https://jendelman.github.io/StageWise/Vignette2.html) after you complete this vignette.) The other columns in the input file contain traits, cofactors, or covariates.

The phenotypes for this tutorial are based on six years (2015-2020) of variety trials at the Hancock Research Station of the University of Wisconsin. Data for the first five years are in the file "pheno1a", which includes a column with an incomplete blocking factor. The 2020 data are provided in the file "pheno1b" and consists of two adjacent, partially replicated trials (preliminary and advanced), with row and range information to illustrate spatial analysis.  

* total yield (Mg per ha) 

* vine maturity (1=early to 9=late)

* specific gravity

* fry color, measured in units of Hunter Lightness (L) after 6 months of storage

The data files also contain the stand count for each plot (out of 15 total plants), which is included as a covariate in the Stage 1 model. 

```{r, fig.width=4,fig.height=4}
pheno1a.file <- system.file("vignette_data", "pheno1a.csv", package = "StageWise")
pheno1a <- read.csv(pheno1a.file)
knitr::kable(head(pheno1a))

pheno1b.file <- system.file("vignette_data", "pheno1b.csv", package = "StageWise")
pheno1b <- read.csv(pheno1b.file)
knitr::kable(head(pheno1b))

tmp <- merge(pheno1a[,c("env","id")],pheno1b[,c("env","id")],all=T)
library(ggplot2)
ggplot(data=tmp,aes(x=env)) + geom_bar() + 
  ylab("Number of plots") + xlab("Environment") + theme_bw() + 
  theme(axis.text.x=element_text(angle=90,vjust=0.5,size=10)) 
```

As is typical of breeding trials, the majority of clones were tested in one year and then dropped, but there is sufficient replication across years to estimate genotype x env interactions.

A data frame with variables "name", "fixed", and "factor" is used to specify which columns of the input file should be included as covariates or cofactors, and whether the effects are fixed or random. We begin with analysis of the 2015-2019 data, using "block" and "stand.count" as cofactor and covariate, respectively:
```{r}
effects <- data.frame(name=c("block","stand.count"),
                      fixed=c(FALSE,TRUE),
                      factor=c(TRUE,FALSE))
effects
library(StageWise)
ans1a <- Stage1(filename=pheno1a.file,traits="total.yield",
                effects=effects,solver="asreml")
```

The `Stage1` function returns a list with several results. List element "blue" is a data frame of the individual BLUEs per environment, and "H2" is the broad-sense heritability on a plot basis per environment.

```{r}
head(ans1a$blue)
ans1a$H2
```

To check for outliers and normality of the residuals, use the plots contained in list element "resid":

```{r}
ans1a$resid$boxplot
ans1a$resid$qqplot
```

For the 2020 data, we will compare a model based on random row and range effects vs. a 2D spline model, which requires the additional argument `spline` to indicate the names of the variables in the input file with the x and y coordinates.

```{r}
effects <- data.frame(name=c("row","range","stand.count","trial"),
                      fixed=c(FALSE,FALSE,TRUE,TRUE),
                      factor=c(TRUE,TRUE,FALSE,TRUE))
effects
model1 <- Stage1(filename=pheno1b.file, traits="total.yield",
                effects=effects, solver="asreml")
model1$H2

model2 <- Stage1(filename=pheno1b.file, traits="total.yield",
                effects=effects[3:4,], solver="spats", spline=c("row","range"))
model2$H2
compare <- merge(model1$blue,model2$blue,by=c("id","env"))
ggplot(data=compare,aes(x=BLUE.x,y=BLUE.y)) + geom_point() + xlab("i.i.d. Random Effects") + ylab("2D Spline") + theme_bw() + geom_abline(intercept=0,slope=1) + coord_cartesian(xlim=c(25,90),ylim=c(25,90)) + ggtitle("2020 Yield BLUEs (Mg/ha)")
```

The above figure shows that the BLUEs are similar with the two different models. A figure showing the 2D spline and spatial distribution of residuals is also returned when SpATS is used:

```{r}
model2$resid$spatial
```

Before proceeding to Stage 2, the BLUEs and variance-covariance matrices from the 2015-19 analysis and 2020 analysis need to be combined. (If other software is used for Stage 1, it can be incorporated in a similar manner.) The model with i.i.d. row and column effects is selected based on the higher estimate for H2.

```{r}
stage1.blue <- rbind(ans1a$blue,model1$blue)
stage1.vcov <- c(ans1a$vcov,model1$vcov)
```

### Marker data

The `read_geno` function reads bi-allelic marker data as a CSV file. If you intend to run GWAS, the option `map=TRUE` indicates the first three columns of the input file are the marker name, chromosome, and position, followed by columns for the individuals. Map information is not used for genomic prediction and can be omitted by using `map=FALSE`, in which case the first column is the marker name and subsequent columns are individuals. The marker data should represent allele dosage, with numeric values between 0 and ploidy. (For compatibility with other software, the coding {-1,0,1} is also allowed for diploids.)

The potato marker data were generated using an Infinium SNP array. Most clones were genotyped with Version 3 (V3) of the array, but some were genotyped with an earlier version (V2). Data from the two different versions were combined using the function `merge_impute` from R package [polyBreedR](https://github.com/jendelman/polyBreedR). The imputation procedure is based on BLUP and generates fractional values of allele dosage, which is compatible with estimating breeding values. 

```{r}
geno.file <- system.file("vignette_data", "geno1.csv", package = "StageWise")
geno <- read.csv(geno.file,check.names=F)
geno[1:4,1:6]

geno <- read_geno(filename=geno.file, ploidy=4, map=TRUE, min.minor.allele=5)
``` 

The function `read_geno` computes the additive relationship (G) matrix and its inverse, which can take some time for large datasets. These matrices and other information needed for the `Stage2` function are stored in the returned object as an S4 class.

### Stage 2

The `Stage2` function uses the BLUEs from Stage 1 as the response variable, as well as their variance-covariance matrix to partition micro-environmental variation from GxE. It is also possible to run `Stage2` without the covariance of the BLUEs from Stage 1, e.g.,  when there are no replicated entries within environment. In this case, use `vcov=NULL`. The benefit of including the covariance information is reflected in the lower value of AIC, which is a penalized likelihood to measure goodness-of-fit.

```{r}
ans2a <- Stage2(data=stage1.blue,vcov=NULL)
ans2b <- Stage2(data=stage1.blue,vcov=stage1.vcov)

data.frame(vcov=c(FALSE,TRUE),AIC=c(ans2a$aic,ans2b$aic))
```

The above Stage 2 analysis did not include the marker data. To partition the genotype effects into additive and residual genetic (including non-additive) effects, the output from `read_geno` is included in the function call. The following example also shows the `silent=FALSE` option (default is TRUE), which shows the convergence progress from ASReml-R.

```{r}
ans2c <- Stage2(data=stage1.blue,vcov=stage1.vcov,geno=geno,silent=FALSE)
ans2c$aic
```

Several other pieces of information are in the list output from `Stage2`. The variance components are contained in "vars" as an S4 class, which is used by the `blup_prep` function. The `summary` command can be used to see the proportion of variance for the different effects:

```{r}
summary(ans2a$vars)
summary(ans2b$vars)
summary(ans2c$vars)
```

The above results show the progression of variance partitioning as more effects are included in the model. Including the covariance of the BLUEs enables splitting of the multi-environment residual into GxE and within-environment residual, and in this example we also observe some reapportionment of the main effect for genotype vs. GxE. When the marker data are included, the genotype effect is separated into additive and residual genetic (g.resid) components; the latter is a random effect with zero covariance, which includes non-additive effects but also potentially additive effects because the G matrix computed from markers is only an estimate of the true covariance matrix. The residual variance changed when the marker data were included because some entries in the phenotype dataset are not present in the genotype file and were therefore automatically excluded by `Stage2`. 

### Pedigree data

Estimating additive relationships using both marker and pedigree data is often beneficial because they have complementary properties. Unlike the G matrix, the A matrix is "sparse", meaning it has zero covariance between unrelated individuals. However, the A matrix does not account for segregation within biparental families or capture LD between founders. The G and A matrices can be combined into an "H" matrix, which also allows ungenotyped individuals to be included in the relationship matrix ([Legarra et al. 2009](https://doi.org/10.3168/jds.2009-2061); [Christensen and Lund 2010](https://doi.org/10.1186/1297-9686-42-2)). 

To illustrate this feature, a three-column pedigree file for the potato population is included with the package. When combining the G and A matrices, their relative weights must be specified using the argument `w` in `read_geno`, such that H = (1-w)G + wA. 
```{r}
ped.file <- system.file("vignette_data", "ped.csv", package = "StageWise")
ped <- read.csv(ped.file)
geno2 <- read_geno(geno.file,ploidy=4,map=TRUE,ped=ped,w=0.1)
ans2d <- Stage2(data=stage1.blue,vcov=stage1.vcov,geno=geno2)

ans2d$aic
summary(ans2d$vars)
```

The above result shows that blending G and A at w=0.1 reduced the AIC and shifted variance from residual genetic into the additive component. This shift occurred because the blended relationship matrix more closely resembles the identity covariance matrix for the residual genetic values. One way to select the blending parameter is based on AIC. When a vector of w values is provided to `read_geno`, the function returns a list output corresponding to those values. For numerical conditioning, a minimum threshold of 1e-5 is used for w.

```{r}
w.vec <- c(1e-5, seq(0.1,0.8,by=0.1))
geno <- read_geno(geno.file,ploidy=4,map=TRUE,ped=ped,w=w.vec)

result <- data.frame(w=w.vec, aic=numeric(9), h2=numeric(9))
for (i in 1:9) {
  ans2 <- Stage2(data=stage1.blue,vcov=stage1.vcov,geno=geno[[i]])
  result$aic[i] <- ans2$aic
  result$h2[i] <- summary(ans2$vars)[1,1]
}
axis.scaling <- diff(range(result$h2))/diff(range(result$aic))
result$y2 <- (result$aic-min(result$aic))*axis.scaling + min(result$h2)
y2lab <- round(seq(min(result$aic),max(result$aic),length.out=5))
y2axis <- y2lab-min(result$aic) + min(result$h2)/axis.scaling

ggplot(result) + geom_line(mapping=aes(x=w,y=h2)) + geom_line(mapping=aes(x=w,y=y2),colour="red") + scale_y_continuous(name="Genomic h2",sec.axis=sec_axis(trans~./axis.scaling,name="AIC",breaks=y2axis,labels=y2lab)) + theme_bw() +  
  theme(axis.text.y.right=element_text(colour="red"),axis.title.y.right=element_text(colour="red")) + ggtitle("Blending G and A for Yield")
```

Based on the above figure, the blending parameter w=0.5 is chosen for further analysis below. The optimal value for w will not be the same for all traits. The code below explores the result for vine maturity.

```{r}
ans1 <- Stage1(pheno1a.file,traits="vine.maturity",
                      effects=data.frame(name=c("block","stand.count"),
                                fixed=c(FALSE,TRUE),
                                factor=c(TRUE,FALSE)))
for (i in 1:9) {
  ans2 <- Stage2(data=ans1$blue,vcov=ans1$vcov,geno=geno[[i]])
  result$aic[i] <- ans2$aic
  result$h2[i] <- summary(ans2$vars)[1,1]
}
axis.scaling <- diff(range(result$h2))/diff(range(result$aic))
result$y2 <- (result$aic-min(result$aic))*axis.scaling + min(result$h2)
y2lab <- round(seq(min(result$aic),max(result$aic),length.out=5))
y2axis <- y2lab-min(result$aic) + min(result$h2)/axis.scaling

ggplot(result) + geom_line(mapping=aes(x=w,y=h2)) + geom_line(mapping=aes(x=w,y=y2),colour="red") + scale_y_continuous(name="Genomic h2",sec.axis=sec_axis(trans~./axis.scaling,name="AIC",breaks=y2axis,labels=y2lab)) + theme_bw() + theme(axis.text.y.right=element_text(colour="red"),axis.title.y.right=element_text(colour="red")) + ggtitle("Blending G and A for Vine Maturity")
```

One last point about `Stage2`: the function returns the fixed effect estimates for each environment under "fixed", and the predicted random effects for the individuals in the training set are returned under "random". This can be useful with very large datasets to avoid further computation, but this information (and a lot more) is also available from the `blup` function, which is described next.

### BLUP Reliability

The calculation of BLUPs is split into two functions: `blup_prep` and `blup`. The primary motivation for doing this was to facilitate quicker exploration of different selection indices, which is illustrated in Vignettes 2 and 3. 

The `blup_prep` function needs the same phenotype information supplied to `Stage2`, i.e, the Stage 1 BLUEs and their covariances, which is then combined with the variance component estimates from Stage 2 to make predictions for all individuals in the genotype file, regardless of whether they have been phenotyped. The object returned by `blup_prep` contains the inverted covariance matrix of the Stage 2 response variable, plus other information needed for BLUP, as an S4 class. This object is provided to the `blup` function, along with the genotype object, and the third argument `what` has possible values of "id" or "marker". Using "id" leads to the prediction of breeding values (BV) and genotypic values (GV) for the individuals. This is illustrated below for yield, using the optimized H matrix from above (w = 0.5).

```{r}
geno1 <- geno[[6]] #geno[[5]] corresponds to w=0.5
ans2 <- Stage2(data=stage1.blue,vcov=stage1.vcov,geno=geno1)
prep <- blup_prep(data=stage1.blue,
              vcov=stage1.vcov,
              geno=geno1,
              vars=ans2$vars)
pred.id <- blup(prep,geno=geno,what="id")
knitr::kable(head(pred.id),digits=2)
```

The columns with `r2` contain the reliability of the BLUPs, which is the squared correlation between the true and predicted values (assuming the model is correct). Breeding values should be used for parent selection, while genotypic values should be used for clone selection. The figure below illustrates an important phenomenon, which is that the reliability of genotypic values is typically higher when using marker data because it improves estimation of the additive component. 

```{r,fig.height=3,fig.width=3}
prep <- blup_prep(data=stage1.blue,
              vcov=stage1.vcov,
              vars=ans2b$vars)
pred2.id <- blup(prep,what="id")

plot.data <- merge(pred2.id,pred.id,by="id")
ggplot(plot.data,aes(x=GV.r2.x,y=GV.r2.y)) + geom_point() + ggtitle("GV Reliability") + theme_bw() + 
  xlab("Without markers") + ylab("With markers") + coord_fixed(ratio=1) + ylim(0.4,1) + xlim(0.4,1) + geom_line(data=data.frame(x=c(0.4,1),y=c(0.4,1)),mapping=aes(x=x,y=y),linetype=2)
```

The `blup_prep` function allows masking the phenotypes for some individuals before making the predictions, which can be used to simulate a particular breeding strategy or to perform cross-validation. All else being equal, predictions for individuals without phenotypes, which is called marker-based selection, have lower reliability than predictions for individuals with phenotypes, which is called marker-assisted selection. To illustrate, we will mask the phenotypes for the most recent cohort of breeding lines in the dataset (which have identifiers that begin with "W17") and compare with the original prediction.

```{r, fig.height=3,fig.width=3}
id <- stage1.blue$id
mask <- data.frame(id=unique(id[substr(id,1,3)=="W17"]))
head(mask)

prep2 <- blup_prep(data=stage1.blue,
              vcov=stage1.vcov,
              geno=geno1,
              vars=ans2$vars,
              mask=mask)
pred2.id <- blup(prep2,geno=geno1,what="id")

#marker-assisted selection (MAS)
tmp1 <- pred.id[pred.id$id %in% mask$id,c("id","BV.r2")]
colnames(tmp1) <- c("id","MAS")

#marker-based selection (MBS)
tmp2 <- pred2.id[pred2.id$id %in% mask$id,c("id","BV.r2")]
colnames(tmp2) <- c("id","MBS")

plot.data <- merge(tmp1,tmp2)
head(plot.data)

ggplot(plot.data,aes(x=MBS,y=MAS)) + geom_point() + theme_bw() + ggtitle("Reliability") +
  xlab("MBS") + ylab("MAS") + coord_fixed(ratio=1) + ylim(0.3,0.8) + xlim(0.3,0.8) + geom_line(data=data.frame(x=c(0.3,0.8),y=c(0.3,0.8)),mapping=aes(x=x,y=y),linetype=2)
```

Using the `mask` argument, one can also specify that individuals are masked only in some environments, which is useful for assessing the accuracy of prediction into new environments based on phenotypes in other environments. This idea is revisited in Vignette 2.

### Marker effects and GWAS

Using "marker" instead of "id" for the `what` argument leads to the prediction of additive marker effects. The marker effects can also be standardized to compute GWAS -log10(p) scores that are equivalent to the traditional fixed effect method ([Duarte et al. (2014)](http://www.biomedcentral.com/1471-2105/15/246); [Bernal Rubio et al. 2016](https://doi.org/10.1111/age.12378)). This calculation is easily parallelized, and the argument `gwas.ncore` specifies how many cores to use (the default is 0, which skips computing the GWAS scores). 

Marker effects offer a convenient way to save the results of the training set analysis and can be used later to make predictions for new individuals. The result is equivalent to the `what="id"` option with `blup` (i.e., RR-BLUP is equivalent to G-BLUP), except in this implementation the BVs computed via marker effects are centered on zero, while the G-BLUP result includes the average value of the fixed effects. The code below relies on the generic method `predict` to compute breeding values via the RR-BLUP method for vine maturity.

```{r,fig.height=4,fig.width=4}
geno1 <- geno[[1]]  #w = 0
ans2 <- Stage2(data=ans1$blue,vcov=ans1$vcov,geno=geno1)
prep <- blup_prep(data=ans1$blue,vcov=ans1$vcov,geno=geno1,vars=ans2$vars)
pred.marker <- blup(data=prep,geno=geno1,what="marker",gwas.ncore=2)
head(pred.marker)

#compare with G-BLUP
RR_BLUP <- predict(geno1,pred.marker)
G_BLUP <- blup(data=prep,geno=geno,what="id")
plot.data <- merge(RR_BLUP,G_BLUP,by="id")
ggplot(plot.data,aes(x=BV.x,y=BV.y)) + geom_point() + xlab("RR-BLUP") + ylab("G-BLUP") + theme_bw()
```

If G is blended with A to perform H-BLUP, then BV predictions via RR-BLUP are similar but no longer equivalent.

```{r,fig.height=4,fig.width=4}
geno1 <- geno[[3]] #w = 0.2
ans2 <- Stage2(data=ans1$blue,vcov=ans1$vcov,geno=geno1)
prep <- blup_prep(data=ans1$blue,vcov=ans1$vcov,geno=geno1,vars=ans2$vars)
pred.marker <- blup(data=prep,geno=geno1,what="marker",gwas.ncore=2)

RR_BLUP <- predict(geno1,pred.marker)
H_BLUP <- blup(data=prep,geno=geno,what="id")
plot.data <- merge(RR_BLUP,H_BLUP,by="id")
ggplot(plot.data,aes(x=BV.x,y=BV.y)) + geom_point() + xlab("RR-BLUP") + ylab("H-BLUP") + theme_bw()
```

The `gwas_threshold` command computes the -log10(p) threshold for QTL discovery based on an effective number of markers ([Moskvina and Schmidt, 2008](https://doi.org/10.1002/gepi.20331)), and `manhattan_plot` displays the result. 

```{r,fig.height=3,fig.width=4}
gwas_threshold(geno1,alpha=0.05,n.core=2)
manhattan_plot(pred.marker,thresh=5.1,rotate.label=TRUE)
```

The GWAS peak on chr05 is near the gene *CDF1*, which is known to have a large effect on potato maturity [(Kloosterman et al. 2013)](https://doi.org/10.1038/nature11912). The following code extracts the most significant marker for the large QTL on chr05 and passes it to `Stage2` as a fixed effect.

```{r}
k <- which.max(pred.marker$gwas.score)
pred.marker[k,]

ans2f <- Stage2(data=ans1$blue,
               vcov=ans1$vcov,
               geno=geno1,
               fix.eff.marker="solcap_snp_c2_22964")

# Fixed effect for the marker
ans2f$fixed$marker

# Proportion of variance
summary(ans2f$vars)
```

The fixed effect estimate of -0.77 for solcap_snp_c2_22964 implies that, on average, each additional copy of the alternate allele reduced vine maturity by 0.77 (on a 1-9 visual scale). According to the proportion of variance table, the solcap_snp_c2_22964 marker accounted for 0.124/(0.124 + 0.264) = 32% of the breeding value.
